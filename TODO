* Overview

Channels (formerly referred to as groups) have writers and readers
(methods).  Each method declares its own write- and read-memberships,
subject to certain restrictions described below.  Channels delegate
to other channels to perform indirect higher-level communications and
to data channels to perform direct communications.  Data channels
represent the medium for the lowest-level communication: from write
operations to read operations on the same data.


* Example

@Channel(
	id = "C",
	via = { "D" }
)
@Channel(
	id = "D",
	via = { @DataChannel("A.x") }
)
class A {
	private int x = 0;

	@Writer("C")
	@Reader("C")
	public void f() {
		g();
	}

	@Writer("D")
	@Reader("D")
	private void g() {
		x++;
	}
}



* Qualified Names 

Channel names work like other Java names.  They are qualified.  Thus
the channel declared with id C above has the qualified name A.C
because it is attached to class A.


* Data Channels

Given the private field x in class A above, we automatically get the
private data channel @DataChannel("A.x").  All reads (not the methods
containing the reads -- think of the reads as getter methods) of field
x are considered as though they were annotated @DataReader("A.x").
All writes (think of setter methods) to field x are automatically
considered to be annotated @DataWriter("A.x").

In coarse-grained object mode, a class A would yield a single
@DataChannel("A") representing all of its fields.  An int array would
yield a protected data channel @DataChannel("int[]") in coarse-grained
array mode and a set of public data channels @DataChannel("int[0]"),
..., @DataChannel("int[n]") in fine-grained array mode.

The inferred data channels described above are all conservative
approximations of real data channels (they allow for a superset of the
actually possible data channel communication) and can be inferred
simply from type information.  Pointer analysis or explicit
declarations could yield more precise data channels.


* Visibility

Channels can be public, protected, or private, according to the
standard Java notions of these keywords.  Channels are not allowed to
be any "more visible" than their least visible writer or reader.  For
example, a channel with a private reader must be a private channel.  A
channel with only public readers and writers can be public, protected,
or private.


Channels may only delegate to other channels that are visible from
the context in which they are declared.


TODO writer visibility and reader visibility.

Channels and their members must be mutually visible.



* Channel Membership

There are two possible (complementary) approaches to declaring
channels and their writers and readers.  Each has certain modularity
enforcement issues that must be addressed (in complementary ways).

** Decentralized Channel Membership Declaration

In this approach, channel declarations include only a name and a list
of delegates if any.  Each method declares what channels it reads from
and writes on.  This approach is illustrated in the example above.  

Decentralized membership is

vis issues

** Centralized Channel Membership Declaration

In this approach, channel declarations include a list of methods that
read from the channel and a list of methods that write on the channel,
in addition to name and delegates.  The sealing issue is moot for this
approach, since the members of a channel can only be modified if the
module containing that channel can be modified.

Centralized membership declaraion requires that we prohibit channels
from declaring reader or writer methods that are not declared in the
same class as the channel.  If this restriction is not provided, new
channels could add methods from an external module, potentially
allowing communication that module intended to disallow.
   
Modules that need to allow communication from outside the module with
methods inside the module may export open channels, described below.



We need some mechanism by which a channel can be made visible for
delegation but closed to additions of new readers and writers.  This
is an artifact of methods declaring their channel memberships as
opposed to channels declaring their members.  There are two options
for generating "final," "sealed," or "read-only" channels:

1. Channels declare their writers and readers instead of methods
   declaring their memberships.

   
2. Channels are "sealed" at compilation, storing the actual list of
   writers and readers of a channel in its declaration in the
   bytecode.  @SealedChannel(id="C", delegates={...}, readers={...},
   writers={...})

** Open Channels
In either case, the need for "open" channels, where one module
communicates with another module, but the opposite end of the
communication is unknown to both module writers, can be served by
"inclusion."  Each module declares the open channel it needs, likely
with only readers or only writers, leaving "the other end" empty.
Only open channels can be included in other channels. @OpenChannel...

The application writer declares a channel that includes its writers
and readers from the two module-declared channels.  Inclusion is
subject to the same visibility constraints as delegation.  Delegation
is not sufficient for this task.  We cannot simply declare a new
channel that delegates to both "endpoint" channels, since the
communication will be happening between readers on one channel and
writers on another.  Delegation requires the communication to happen
on a single delegate channel at some level.  Perhaps a channel that
includes other channels should be called a "link." For example:
@LinkChannel(id="L", include={"C1", "C2"})

The distinction between open channels, which can be included in other
channels, and regular channels, which cannot be included, is
necessary, since library writers will want to seal certain channels
where communication *could* but *should not* occur.  For these
channels application writers should not be able to change the allowed
communication.


If you need communication between A.f and B.g, even assuming both are
public (and thus mutually visible), you must export and open channel
for at least one. You're not allowed to reference methods outside the
current class, only channels.


* Modularity

Good OO design keeps @DataChannel communication within classes, or at
least packages.  Higher-level communication on @Channels may cut
across class or package boundaries, but it delegates to @DataChannels
for the real data communication.

Of course, "Good OO design" is not pervasive. I write plenty of code
that has @DataChannel communication across class boundaries. *** I
cross package boundaries much less often. ***


* Static Sanity Checking

Communication is only possible (and I mean possible, not "allowed" or
"intended" or "expected") on a @Channel C that meets the following
criteria:

1. Every writer of C must:

   a. write to a @DataChannel that is a delegate of C and that some
   	  reader of C reads from; or

   b. call (or be) a writer of a @Channel that is a delegate of C and
      that has some reader that is called by (or is) a reader of C.

2. Every reader of C must: 

   a. read from a @DataChannel that is a delegate of C and that some
   	  writer of C writes to; or

   b. call (or be) a reader of a @Channel that is a delegate of C and
      that has some writer that is called by (or is) a writer of C.

3. As a corollary to 1 and 2, every @Channel must delegate to at least
   one @Channel or @DataChannel.

These criteria may be extended from the form "for each reader there
must be some writer..." to "for each reader, for all writers..." to
check that every communication declared by the @Channel is "possible."
(Of course we're still using a broader approximation of possible.)








* Open Questions (To do)


** Visible Data Channels and Non-Externally Visible Methods

Consider a non-externally visible library method that could (and,
regardless of design quality judgement, should be allowed to)
communicate with other methods outside the library package via some
public data channel (e.g. an array or a public field).  Example:

private Object[] expand(Object[] array) {
	Object[] tmp = new Object[array.length * 2];
	for (int i = 0; i < array.length; i++) {
		tmp[i] = array[i];
	}
	return tmp;
}

The expand method should probably inlined in this case, so that any
communication happening in it gets reassigned up to some externally
visible method.  Is that always what you want to do?

Is this common?

Should public/private work more like .mli?

Channels, not individual writers or readers of channels, are either
internal-only (private) or externally visible (public).  It would
probably work to allow certain members of a channel to be private and
others public, but it seems confusing and a less intuitive
alternative.  Members of externally visible channels must themselves
be externally visible.


A Channel with member m may delegate to another channel that also has
m as a member.  If m is a writer in both or a reader in both then m
need not call itself to delegate. The delegation is legit from the
original call.


INHERITANCE!

* Semantics





* Construct bugs.
